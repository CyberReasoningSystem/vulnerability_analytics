import os
import archr
import rex
import logging
import subprocess
from archr.analyzers.rr import *

import docker

from angr import SimState

tests_location = os.path.dirname(os.path.realpath(__file__))

def build_container():
    subprocess.check_call(['make'], cwd=os.path.join(tests_location, 'hammer_controller'))
    print("Tests Locations: ", tests_location)

def __build_image_if_not_already_built(
        self, client: docker.DockerClient
    ) -> None:
        if self.configuration.IMAGE_ID:
            return

        images = client.images.build(
            path=".",
            pull=True,
            buildargs={
                "USER_ID": str(os.getuid()),
                "GROUP_ID": str(os.getgid()),
            },
        )
        image = images[0]

        return image



def test_binary():

    # build_container()

    t = archr.targets.DockerImageTarget('test:source').build().start()
    # tb = archr.arsenal.RRTracerBow(t, local_trace_dir='/tmp/rex_hammer_controller_trace', symbolic_fd=0)
    print("OK Docker build and arsenal")


    # time.sleep(30)
    crash = rex.Crash(t, bytes("./source.bin;--string,santa\n", 'utf-8'), aslr=False, use_rop=False)#, tracer_bow=tb)
    print("OK crash ?")
    print(crash.crash_types)
    print("Is the crash explorable?")

    print(type(crash.prev)) # State of the current evaluated crash -> Crash.py line 455
    print(type(crash.state)) # Crash.py line 455

    # State plugins -> history | https://docs.angr.io/core-concepts/states#the-history-plugin

    print(crash.state.history.descriptions)

    # State plugins callstack plugin | https://docs.angr.io/core-concepts/states#the-callstack-plugin
    print("----------------------------------")
    print(crash.state.callstack) # Backtrace
    print("----------------------------------")
    print(crash.state.memory) # DefaultMemory object
    print("----------------------------------")
    print(crash.state.memory) # DefaultMemory object
    print("----------------------------------")
    print(crash.state.globals) # SimStateGlobals object
    print("----------------------------------")
    print(crash.state.registers) # DefaultMemory object
    print("----------------------------------")
    print(crash.state.mem) # SimMemView
    print("----------------------------------")
    print(crash.state.solver) # SimSolver Object
    print("----------------------------------")
    print("Start history")
    import json 
    print(crash.state.history.descriptions) # string descriptions of each round of execution?
    print(crash.state.history.bbl_addrs) # list of basic blocks addresses executed
    print(crash.state.history.jumpkinds) # list of the dispozition of each of control flow transitions
    print(crash.state.history.jump_guards) # list of the conditions guarding the branches
    print(crash.state.history.events) # "interesting events" during execution, such as 
                                    # symbolic jump conditions
    print("----------------------------------")

    # print(json.dumps(crash.state.history, indent = 4))

    print("----------------------------------")
    print(hex(crash.state.callstack.ret_addr))
    print("----------------------------------")
    print(hex(crash.state.callstack.stack_ptr))
    print("----------------------------------")
    print(hex(crash.state.callstack.call_site_addr))
    print("----------------------------------")
    print(hex(crash.state.callstack.func_addr))
    print("----------------------------------")
    crash.state.get_plugin("test_name")

    return None
    exploit = crash.exploit()
    print(exploit.arsenal)
    assert 'rop_chess_control' in exploit.arsenal
    exploit.arsenal['rop_chess_control'].script()
    exploit.arsenal['rop_chess_control'].script("x2.py")


def main():
    logging.getLogger("angr.exploration_techniques.tracer").setLevel(logging.DEBUG)
    logging.getLogger("rex").setLevel(logging.DEBUG)

    test_binary()


if __name__ == '__main__':
    main()
